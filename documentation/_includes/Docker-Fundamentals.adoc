:sectnums:
:sectnumlevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

:toc:

= Docker Fundamentals

In this unit, we will get familiar with Docker Containers and the Docker CLI.  This unit is designed to explain and highlight 
some of the significant security concerns around the native Docker approach to Linux containers.

== Docker Installation and Setup

=== Run the docker-install script

Installation and configuration of docker has been condensed into an Ansible Playbook for simplicity.

.[root@workstation ~]#
----
cd ~/OCP-Workshop
bash 04-docker-install.sh
----

You can review the playbook if you have any questions as to the steps required to install docker.  The installation takes about 2 minutes to complete.

.Your output should look like this
[source,indent=4]
----
## Calling ansible playbook: ./playbooks/docker-install.yml

PLAY [docker] **********************************************

TASK [Gathering Facts] *************************************
ok: [docker.example.com]

TASK [PING all hosts to ensure we are alive and ready] *****
ok: [docker.example.com]

TASK [YUM install docker docker-distribution] **************
changed: [docker.example.com]

TASK [SERVICE STOP firewalld] ******************************
ok: [docker.example.com]

TASK [SERVICE START docker] ********************************
changed: [docker.example.com]

TASK [SERVICE START docker-distribution] *******************
changed: [docker.example.com]

TASK [CMD: Pull rhel7 image] *******************************
changed: [docker.example.com]

PLAY RECAP *************************************************
docker.example.com         : ok=7    changed=4    unreachable=0    failed=0

real    1m49.861s
user    0m14.865s
sys     0m8.440s
----

=== Connect to System : docker.example.com

There is a dedicated VM we will use for the docker exercises.  From workstation.example.com, you should be able to ssh to docker.example.com as 'root' without any prompts for credentials.

.[root@workstation ~]#
----
ssh docker.example.com
----

Now you are ready to begin your exercises with docker.


== Docker Basics

=== Host Networking

Before you start launching containers everywhere, let us take a moment to explore the host and discuss a few things.  First, have look at the network.

.[root@docker ~]#
----
iptables -L
----

.Your output should look like this
[source,indent=4]
----
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy DROP)
target     prot opt source               destination
DOCKER-ISOLATION  all  --  anywhere             anywhere
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain DOCKER (1 references)
target     prot opt source               destination

Chain DOCKER-ISOLATION (1 references)
target     prot opt source               destination
RETURN     all  --  anywhere             anywhere
----

=== Docker Info

Now have a look at the general docker information.

.[root@docker ~]#
----
docker info
----

.Your output should look like this
[source,indent=4]
----
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 1
Server Version: 1.13.1
Storage Driver: overlay2
 Backing Filesystem: xfs
 Supports d_type: false
 Native Overlay Diff: true
Logging Driver: journald
Cgroup Driver: systemd
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Authorization: rhel-push-plugin
Swarm: inactive
Runtimes: docker-runc runc
Default Runtime: docker-runc
Init Binary: /usr/libexec/docker/docker-init-current
containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)
runc version: 5eda6f6fd0c2884c2c8e78a6e7119e8d0ecedb77 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)
init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)
Security Options:
 seccomp
  WARNING: You're not using the default seccomp profile
  Profile: /etc/docker/seccomp.json
 selinux
Kernel Version: 3.10.0-862.9.1.el7.x86_64
Operating System: Red Hat Enterprise Linux
OSType: linux
Architecture: x86_64
Number of Docker Hooks: 3
CPUs: 1
Total Memory: 1.796 GiB
Name: docker.example.com
ID: L3CI:Z35C:C6FW:3OYK:OPJM:KMZY:VRHZ:YR7C:OEIP:EZW4:FYEM:RN3A
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://registry.access.redhat.com/v1/
WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Registries: registry.access.redhat.com (secure), docker.io (secure)
----


== Your First Container

=== Hello World

.[root@docker ~]#
----
docker run rhel7 echo "hello world"
----

.Your output should look like this
[source,indent=4]
----
hello world
----

Well that was really boring!! What did we learn from this?  For starters, you should have noticed how fast the container launched and then concluded.  Compare that with traditinal virtualization where you power up, wait for bios, what for grub, wait for the boot kernel, final pivot root to a running OS and then finally the application launches.

Let us run a few more commands to see what else we can gleen.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS                          PORTS               NAMES
2f0a2c755a7a        rhel7               "echo 'hello world'"   About a minute ago   Exited (0) About a minute ago                       focused_knuth
----

Now let us run the exact same command again.

.[root@mdocker ~]#
----
docker run rhel7 echo "hello world"
----

.Your output should look like this
[source,indent=4]
----
hello world
----

Check out 'docker info' one more time and you should notice a few changes.

.[root@mdocker ~]#
----
docker info
----

.Your output should look like this
[source,indent=4]
----
Containers: 2
 Running: 0
 Paused: 0
 Stopped: 2
Images: 1
Server Version: 1.13.1
Storage Driver: overlay2
 Backing Filesystem: xfs
 Supports d_type: false
 Native Overlay Diff: true
Logging Driver: journald
Cgroup Driver: systemd
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Authorization: rhel-push-plugin
Swarm: inactive
Runtimes: docker-runc runc
Default Runtime: docker-runc
Init Binary: /usr/libexec/docker/docker-init-current
containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)
runc version: 5eda6f6fd0c2884c2c8e78a6e7119e8d0ecedb77 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)
init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)
Security Options:
 seccomp
  WARNING: You're not using the default seccomp profile
  Profile: /etc/docker/seccomp.json
 selinux
Kernel Version: 3.10.0-862.9.1.el7.x86_64
Operating System: Red Hat Enterprise Linux
OSType: linux
Architecture: x86_64
Number of Docker Hooks: 3
CPUs: 1
Total Memory: 1.796 GiB
Name: docker.example.com
ID: XL2H:E335:S6UF:BYHT:OHQ2:6LEJ:ZZQK:A2KA:PBUX:CASW:NRFA:AGM2
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://registry.access.redhat.com/v1/
WARNING: bridge-nf-call-iptables is disabled
WARNING: bridge-nf-call-ip6tables is disabled
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Registries: registry.access.redhat.com (secure), docker.io (secure)
----

You should notice that the number of containers has incremented to 2, and that the amount of storage consumed has grown.  

=== Cleanup

Run 'docker ps -a' to the IDs of the exited containers.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                      PORTS               NAMES
8cb4816f016d        rhel7               "echo 'hello world'"   2 minutes ago       Exited (0) 2 minutes ago                        focused_swirles
2f0a2c755a7a        rhel7               "echo 'hello world'"   13 minutes ago      Exited (0) 13 minutes ago                       focused_knuth
----

Using the container UIDs from the above output, you can now clean up the 'exited' containers.

.[root@docker ~]#
----
docker rm <CONTAINER-ID> <CONTAINER-ID>
----

Now you should be able to run 'docker ps -a' again, and the results should come back empty.

.[root@docker ~]#
----
docker ps -a
----




== Understanding Container Namespaces

=== UTS / Hostname

.[root@docker ~]#
----
docker run rhel7 cat /proc/sys/kernel/hostname
----

.Your output should look like this
[source,indent=4]
----
c60f5bff9560
----

So what we have learned is that the hostname in the container's namespace is NOT the same as the host platform (docker.example.com).  It is unique and is by default identical to the container's ID.  You can verify this with 'docker ps- a'.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                      PORTS               NAMES
c60f5bff9560        rhel7               "cat /proc/sys/ker..."   42 seconds ago       Exited (0) 41 seconds ago                       zealous_austin
----


=== Process ID

.[root@docker ~]#
----
docker run rhel7 ps -ef
----

.Your output should look like this
[source,indent=4]
----
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 16:39 ?        00:00:00 ps -ef
----

=== Filesystem



=== Network

Now let us run a command to report the network configuration from within the a container's namespace.

.[root@docker ~]#
----
docker run rhel7 /usr/sbin/ip addr show eth0
----

.Your output should look like this
[source,indent=4]
----
container_linux.go:247: starting container process caused "exec: \"/usr/sbin/ip\": stat /usr/sbin/ip: no such file or directory"
/usr/bin/docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused "exec: \"/usr/sbin/ip\": stat /usr/sbin/ip: no such file or directory".
----

In this instance, then image that we are using (ie: rhel7) does not have the traditional commmandline utilities a user might expect.  For example, a common tools to configure network interfaces like 'ip' simply aren't there.

So for this exercise, we leverage something called a 'bind mount' to effectively mirror a portion of the host's filesystem into the container's namespace.  Bind mounts are declared using the '-v' option.  In the example below, /usr/sbin from the host will be exposed and accessible to the containers namespace mounted at '/usr/bin' (ie: /usr/sbin:/usr/sbin).

NOTE: Using bind mounts is generally suitable for debugging, but not a good practice as a design decision for enterprise container strategies.  After all, creating dependencies between applications and host operating systems is what we are trying to get away from.

.[root@docker ~]#
----
docker run -v /usr/sbin:/usr/sbin --rm rhel7 /usr/sbin/ip addr show eth0
----

.Your output should look like this
[source,indent=4]
----
16: eth0@if17: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link tentative
       valid_lft forever preferred_lft forever
----







== Your First Containerized Application

.[root@docker ~]#
----
mkdir -p /var/www/html
echo "Server up and running" > /var/www/html/test.txt
restorecon -Rv /var/www
docker run -d -p 8000:8000 --name="python_web" \
    -v /usr/sbin:/usr/sbin \
    -v /usr/bin:/usr/bin \
    -v /usr/lib64:/usr/lib64 \
    -v /var/www/html:/var/www/html \
    -w /var/www/html  \
    rhel /bin/python -m SimpleHTTPServer 8000
----


.[root@docker ~]#
----
netstat -tulpn | grep 8000

curl localhost:8000/test.txt
----


.Your output should look like this
[source,indent=4]
----
Coming Soon...
----











[discrete]
== End of Unit

link:../OCP-Workshop.adoc[Return to TOC]

////
Always end files with a blank line to avoid include problems.
////
