:sectnums:
:sectnumlevels: 2
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

:toc:

= Docker Fundamentals

In this unit, we will get familiar with Docker Containers and the Docker CLI.  This unit is designed to explain and highlight 
some of the significant security concerns around the native Docker approach to Linux containers.

== Docker Installation and Setup

=== Run the docker-install script

Installation and configuration of docker has been condensed into an Ansible Playbook for simplicity.  This installation also closely mimics the configuration used for supporting Openshift.  Primarily, the default storage configuration was changed to utilize logical volumes instead of the default filesystem based layout.

.[root@workstation ~]#
----
cd ~/OCP-Workshop
bash 04-docker-install.sh
----

You can review the playbook if you have any questions as to the steps required to install docker.  The installation takes about 2 minutes to complete.

.Your output should look like this
[source,indent=4]
----
## Calling ansible playbook: ./playbooks/docker-install.yml

PLAY [docker] *****************************************************************************************************************************

TASK [Gathering Facts] ********************************************************************************************************************
ok: [docker.example.com]

TASK [PING all hosts to ensure we are alive and ready] ************************************************************************************
ok: [docker.example.com]

TASK [YUM install docker docker-distribution] *********************************************************************************************
changed: [docker.example.com]

TASK [TEMPLATE modify /etc/motd] **********************************************************************************************************
changed: [docker.example.com]

TASK [TEMPLATE install /etc/sysconf/docker-storage-setup] *********************************************************************************
changed: [docker.example.com]

TASK [SERVICE STOP firewalld] *************************************************************************************************************
ok: [docker.example.com]

TASK [SERVICE START docker] ***************************************************************************************************************
changed: [docker.example.com]

TASK [SERVICE START docker-distribution] **************************************************************************************************
changed: [docker.example.com]

TASK [CMD: Pull rhel7 image] **************************************************************************************************************
changed: [docker.example.com]

RUNNING HANDLER [reconfig storage step-1] *************************************************************************************************
changed: [docker.example.com]

RUNNING HANDLER [reconfig storage step-2] *************************************************************************************************
 [WARNING]: Consider using file module with state=absent rather than running rm

changed: [docker.example.com]

RUNNING HANDLER [reconfig storage step-3] *************************************************************************************************
changed: [docker.example.com]

PLAY RECAP ********************************************************************************************************************************
docker.example.com         : ok=12   changed=9    unreachable=0    failed=0

real    1m59.845s
user    0m16.577s
sys     0m7.443s
----

=== Connect to System : docker.example.com

There is a dedicated VM we will use for the docker exercises.  From workstation.example.com, you should be able to ssh to docker.example.com as 'root' without any prompts for credentials.

.[root@workstation ~]#
----
ssh docker.example.com
----

Now you are ready to begin your exercises with docker.


== Docker Basics

=== Host Networking

Before you start launching containers everywhere, let us take a moment to explore the host and discuss a few things.  First, have look at the network.

.[root@docker ~]#
----
iptables -L
----

.Your output should look like this
[source,indent=4]
----
Chain INPUT (policy ACCEPT)
target     prot opt source               destination

Chain FORWARD (policy DROP)
target     prot opt source               destination
DOCKER-ISOLATION  all  --  anywhere             anywhere
DOCKER     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere             ctstate RELATED,ESTABLISHED
ACCEPT     all  --  anywhere             anywhere
ACCEPT     all  --  anywhere             anywhere

Chain OUTPUT (policy ACCEPT)
target     prot opt source               destination

Chain DOCKER (1 references)
target     prot opt source               destination

Chain DOCKER-ISOLATION (1 references)
target     prot opt source               destination
RETURN     all  --  anywhere             anywhere
----

=== Docker Info

Now have a look at the general docker information.

.[root@docker ~]#
----
docker info
----

.Your output should look like this
[source,indent=4]
----
Containers: 0
 Running: 0
 Paused: 0
 Stopped: 0
Images: 0
Server Version: 1.13.1
Storage Driver: devicemapper
 Pool Name: docker--vg-docker--pool
 Pool Blocksize: 524.3 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: xfs
 Data file:
 Metadata file:
 Data Space Used: 19.92 MB
 Data Space Total: 4.266 GB
 Data Space Available: 4.246 GB
 Metadata Space Used: 40.96 kB
 Metadata Space Total: 12.58 MB
 Metadata Space Available: 12.54 MB
 Thin Pool Minimum Free Space: 426.2 MB
 Udev Sync Supported: true
 Deferred Removal Enabled: true
 Deferred Deletion Enabled: true
 Deferred Deleted Device Count: 0
 Library Version: 1.02.146-RHEL7 (2018-01-22)
Logging Driver: journald
Cgroup Driver: systemd
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Authorization: rhel-push-plugin
Swarm: inactive
Runtimes: docker-runc runc
Default Runtime: docker-runc
Init Binary: /usr/libexec/docker/docker-init-current
containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)
runc version: 5eda6f6fd0c2884c2c8e78a6e7119e8d0ecedb77 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)
init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)
Security Options:
 seccomp
  WARNING: You're not using the default seccomp profile
  Profile: /etc/docker/seccomp.json
 selinux
Kernel Version: 3.10.0-862.9.1.el7.x86_64
Operating System: Red Hat Enterprise Linux
OSType: linux
Architecture: x86_64
Number of Docker Hooks: 3
CPUs: 1
Total Memory: 1.796 GiB
Name: docker.example.com
ID: JNRB:NRG2:DZMK:XJJF:4Z2Z:NJMI:E24H:3WGJ:FCGE:XN5K:HM6O:QVAX
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://registry.access.redhat.com/v1/
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Registries: registry.access.redhat.com (secure), docker.io (secure)
----


== Your First Container

=== Hello World

.[root@docker ~]#
----
docker run rhel7 echo "hello world"
----

.Your output should look like this
[source,indent=4]
----
hello world
----

Well that was really boring!! What did we learn from this?  For starters, you should have noticed how fast the container launched and then concluded.  Compare that with traditinal virtualization where you power up, wait for bios, what for grub, wait for the boot kernel, final pivot root to a running OS and then finally the application launches.

Let us run a few more commands to see what else we can gleen.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                CREATED              STATUS                          PORTS               NAMES
2f0a2c755a7a        rhel7               "echo 'hello world'"   About a minute ago   Exited (0) About a minute ago                       focused_knuth
----

Now let us run the exact same command again.

.[root@mdocker ~]#
----
docker run rhel7 echo "hello world"
----

.Your output should look like this
[source,indent=4]
----
hello world
----

Check out 'docker info' one more time and you should notice a few changes.

.[root@mdocker ~]#
----
docker info
----

.Your output should look like this
[source,indent=4]
----
Containers: 2
 Running: 0
 Paused: 0
 Stopped: 2
Images: 1
Server Version: 1.13.1
Storage Driver: devicemapper
 Pool Name: docker--vg-docker--pool
 Pool Blocksize: 524.3 kB
 Base Device Size: 10.74 GB
 Backing Filesystem: xfs
 Data file:
 Metadata file:
 Data Space Used: 310.9 MB
 Data Space Total: 4.266 GB
 Data Space Available: 3.955 GB
 Metadata Space Used: 147.5 kB
 Metadata Space Total: 12.58 MB
 Metadata Space Available: 12.44 MB
 Thin Pool Minimum Free Space: 426.2 MB
 Udev Sync Supported: true
 Deferred Removal Enabled: true
 Deferred Deletion Enabled: true
 Deferred Deleted Device Count: 0
 Library Version: 1.02.146-RHEL7 (2018-01-22)
Logging Driver: journald
Cgroup Driver: systemd
Plugins:
 Volume: local
 Network: bridge host macvlan null overlay
 Authorization: rhel-push-plugin
Swarm: inactive
Runtimes: docker-runc runc
Default Runtime: docker-runc
Init Binary: /usr/libexec/docker/docker-init-current
containerd version:  (expected: aa8187dbd3b7ad67d8e5e3a15115d3eef43a7ed1)
runc version: 5eda6f6fd0c2884c2c8e78a6e7119e8d0ecedb77 (expected: 9df8b306d01f59d3a8029be411de015b7304dd8f)
init version: fec3683b971d9c3ef73f284f176672c44b448662 (expected: 949e6facb77383876aeff8a6944dde66b3089574)
Security Options:
 seccomp
  WARNING: You're not using the default seccomp profile
  Profile: /etc/docker/seccomp.json
 selinux
Kernel Version: 3.10.0-862.9.1.el7.x86_64
Operating System: Red Hat Enterprise Linux
OSType: linux
Architecture: x86_64
Number of Docker Hooks: 3
CPUs: 1
Total Memory: 1.796 GiB
Name: docker.example.com
ID: JNRB:NRG2:DZMK:XJJF:4Z2Z:NJMI:E24H:3WGJ:FCGE:XN5K:HM6O:QVAX
Docker Root Dir: /var/lib/docker
Debug Mode (client): false
Debug Mode (server): false
Registry: https://registry.access.redhat.com/v1/
Experimental: false
Insecure Registries:
 127.0.0.0/8
Live Restore Enabled: false
Registries: registry.access.redhat.com (secure), docker.io (secure)
----

You should notice that the number of containers has incremented to 2, and that the amount of storage consumed has grown.  

=== Cleanup

Run 'docker ps -a' to the IDs of the exited containers.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                CREATED             STATUS                      PORTS               NAMES
8cb4816f016d        rhel7               "echo 'hello world'"   2 minutes ago       Exited (0) 2 minutes ago                        focused_swirles
2f0a2c755a7a        rhel7               "echo 'hello world'"   13 minutes ago      Exited (0) 13 minutes ago                       focused_knuth
----

Using the container UIDs from the above output, you can now clean up the 'exited' containers.

.[root@docker ~]#
----
docker rm <CONTAINER-ID> <CONTAINER-ID>
----

Now you should be able to run 'docker ps -a' again, and the results should come back empty.

.[root@docker ~]#
----
docker ps -a
----




== Understanding Container Namespaces

=== UTS / Hostname

.[root@docker ~]#
----
docker run rhel7 cat /proc/sys/kernel/hostname
----

.Your output should look like this
[source,indent=4]
----
c60f5bff9560
----

So what we have learned is that the hostname in the container's namespace is NOT the same as the host platform (docker.example.com).  It is unique and is by default identical to the container's ID.  You can verify this with 'docker ps- a'.

.[root@docker ~]#
----
docker ps -a
----

.Your output should look like this
[source,indent=4]
----
CONTAINER ID        IMAGE               COMMAND                  CREATED              STATUS                      PORTS               NAMES
c60f5bff9560        rhel7               "cat /proc/sys/ker..."   42 seconds ago       Exited (0) 41 seconds ago                       zealous_austin
----


=== Process ID

.[root@docker ~]#
----
docker run rhel7 ps -ef
----

.Your output should look like this
[source,indent=4]
----
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 16:39 ?        00:00:00 ps -ef
----

=== Network

Now let us run a command to report the network configuration from within the a container's namespace.

.[root@docker ~]#
----
docker run rhel7 ip addr show eth0
----

.Your output should look like this
[source,indent=4]
----
container_linux.go:247: starting container process caused "exec: \"ip\": executable file not found in $PATH"
/usr/bin/docker-current: Error response from daemon: oci runtime error: container_linux.go:247: starting container process caused "exec: \"ip\": executable file not found in $PATH".
----

What just happened?

For the most part, containers are not meant for interactive (user) sessions.  In this instance, then image that we are using (ie: rhel7) does not have the traditional commmandline utilities a user might expect.  Common tools to configure network interfaces like 'ip' simply aren't there.

So for this exercise, we leverage something called a 'bind mount' to effectively mirror a portion of the host's filesystem into the container's namespace.  Bind mounts are declared using the '-v' option.  In the example below, /usr/sbin from the host will be exposed and accessible to the containers namespace mounted at '/usr/bin' (ie: /usr/sbin:/usr/sbin).

NOTE: Using bind mounts is generally suitable for debugging, but not a good practice as a design decision for enterprise container strategies.  After all, creating dependencies between applications and host operating systems is what we are trying to get away from.

.[root@docker ~]#
----
docker run -v /usr/sbin:/usr/sbin --rm rhel7 /usr/sbin/ip addr show eth0
----

.Your output should look like this
[source,indent=4]
----
16: eth0@if17: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:acff:fe11:2/64 scope link tentative
       valid_lft forever preferred_lft forever
----

A couple more commands to understand the network setup.

Let us begin by examining the '/etc/hosts' file.

.[root@docker ~]#
----
docker run --rm rhel7 cat /etc/hosts
----

How does the container resolve hostnames (ie: DNS)?

.[root@docker ~]#
----
docker run --rm rhel7 cat /etc/resolv.conf
----

Take a look at the routing table.
Pay attention now, the route command is in '/usr/bin'.  Take a look at the routing table for the container namespace.

.[root@docker ~]#
----
docker run -v /usr/bin:/usr/bin --rm rhel7 /usr/bin/route -n
----

=== Filesystem

.[root@docker ~]#
----
docker run rhel7 df -h
----

.Your output should look like this
[source,indent=4]
----
/dev/mapper/docker-253:1-33666640-20cf8eb18a0841286bb681bf8694ce2d60cab4c4ce027347025dd253edd52975   10G  259M  9.8G   3% /
tmpfs                                                                                               920M     0  920M   0% /dev
tmpfs                                                                                               920M     0  920M   0% /sys/fs/cgroup
/dev/mapper/rhel_pwob--r7-root                                                                      8.5G  2.3G  6.3G  27% /etc/hosts
shm                                                                                                  64M     0   64M   0% /dev/shm
tmpfs                                                                                               920M     0  920M   0% /proc/scsi
tmpfs                                                                                               920M     0  920M   0% /sys/firmware
----

You were introduced to Bind-Mounts in the previous section.  Let us examine what the filesystems looks like with an active Bind-Mount.

.[root@docker ~]#
----
docker run -v /usr/bin:/usr/bin rhel7 df -h
----

.Your output should look like this
[source,indent=4]
----
Filesystem                                                                                          Size  Used Avail Use% Mounted on
/dev/mapper/docker-253:1-33666640-0173b6e98755b921811ba7ea405de9c47ebc16721271e5fc29b09e9e18807e64   10G  259M  9.8G   3% /
tmpfs                                                                                               920M     0  920M   0% /dev
tmpfs                                                                                               920M     0  920M   0% /sys/fs/cgroup
/dev/mapper/rhel_pwob--r7-root                                                                      8.5G  2.3G  6.3G  27% /usr/bin
shm                                                                                                  64M     0   64M   0% /dev/shm
tmpfs                                                                                               920M     0  920M   0% /proc/scsi
tmpfs                                                                                               920M     0  920M   0% /sys/firmware
----

Notice above how there is now a dedicated mount point for /usr/bin.  Bind-Mounts can be a very powerful tool (primarily for diagnostics) to termporarily inject tools and files that are not normally part of a container image.  Using bind mounts as a design decision for enterprise container strategies is folly.  Creating direct dependencies between containerized applications and host operating systems is what we are trying to get away from.

== Your First Containerized Application

=== Setup

.[root@docker ~]#
----
mkdir -p /var/www/html

echo "Server up and running" > /var/www/html/test.txt

restorecon -Rv /var/www
----

=== Deployment

.[root@docker ~]#
----
docker run -d --name="python_web" \
    -v /usr/bin:/usr/bin \
    -v /usr/lib64:/usr/lib64 \
    -v /var/www/html:/var/www/html \
    -w /var/www/html  \
    -p 8000:8000 \
    rhel /bin/python -m SimpleHTTPServer 8000
----

=== Validation


.[root@docker ~]#
----
netstat -tulpn | grep 8000
----


.[root@docker ~]#
----
curl localhost:8000/test.txt
----



.Your output should look like this
[source,indent=4]
----
Coming Soon...
----











[discrete]
== End of Unit

link:../OCP-Workshop.adoc[Return to TOC]

////
Always end files with a blank line to avoid include problems.
////
